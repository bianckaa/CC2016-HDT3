https://panthema.net/2013/sound-of-sorting/SoS-CheatSheet.pdf


Function insertionSort(A : Array of Element; n : N)
for i := 2 to n do // {A[1]} is sorted
j := i
while (j > 0) & (A[j − 1] > A[j]) // find right position j
swap(A[j − 1], A[j]) // move larger elements to the back
j := j − 1
endwhile
invariant A[1] ≤ · · · ≤ A[i]
endfor

Function mergeSort(A : Array of Element; lo, hi : N)
if hi − lo ≤ 1 then return // base case
mid := (lo + hi)/2 // middle element
mergeSort(lo, mid), mergeSort(mid, hi) // sort halves
B := allocate (Array of Element size hi − lo)
i := lo, j := mid, k := 1 // running indexes
while (i < mid) & (j < hi)
if A[i] < A[j] B[k++] := A[i++] // merge!
else B[k++] := A[j++]
endwhile
while i < mid do B[k++] := A[i++] // copy remainder
while j < hi do B[k++] := A[j++]
A[lo, . . . , hi − 1] := B[1, . . . ,(hi − lo)] // copy back
dispose (B)

Procedure quickSort(A : Array of Element; `, r : N)
if ` ≥ r then return
q := pickPivotPos(A, `, r)
m := partition(A, `, r, q)
quickSort(A, `, m − 1), quickSort(A, m + 1, r)
Function partition(A : Array of Element; `, r : N, q : N)
p := A[q] // pivot element
swap(A[q], A[r]) // swap to the end
i := `
invariant ≤ p > p ? p
` i j r
for j := ` to r − 1 do
if A[j] ≤ p then
swap(A[i], A[j]), i++ // move smaller to the front
assert ≤ p > p p
` i r
swap(A[i], A[r]) // move pivot into the middle
assert ≤ p p > p
` i r
return i

Procedure LSDRadixSort(A : Array [1 . . . n] of Element)
K := 4 // number of buckets per round
D := dlogK(max{A[i] + 1 | i = 1, . . . , n})e // calculate number of rounds
B := allocate (Array of Element size n) // temporary array B
for d := 0 to D − 1 do // sort by the d-th K-digit.
redefine key(x) := (x div Kd
) mod K
KSortCopy(A, B, n), swap(A, B) // sort from A to B, and swap back
invariant A ist nach den K-Ziffern d..0 sortiert.
dispose (B)
Procedure KSortCopy(A, B : Array [1 . . . n] of Element; K : N)
c = h0, . . . , 0i : Array [0 . . . K − 1] of N
for i := 1 to n do c[key(A[i])]++ // count occurrences
sum := 1
for k := 0 to K − 1 do // exclusive prefix sum
next := sum + c[k], c[k] := sum, sum := next
for i := 1 to n do
B

c[key(A[i])]++
:= A[i] // move element A[i] into bucket of B


Procedure gnomeSort(A : Array [1 . . . n] of Element)
i := 2
while i ≤ n do
if A[i] ≥ A[i − 1] then // move to right while
i++ // elements grow larger
else
swap(A[i], A[i − 1]) // swap backwards while
if i > 2 then i−− // element grow smaller
endwhile
